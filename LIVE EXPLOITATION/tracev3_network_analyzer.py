#!/usr/bin/env python3
"""
tracev3 Network Module - CVE-2026-25251
Extract and analyze network activity from iOS livelogtrace.v3 files

Focus Areas:
- iCloud/CloudKit API connections
- Apple Push Service activity
- Suspicious IP addresses and domains
- Network error patterns indicating C2 failures
- Temporal correlation with debug events

Usage:
  python3 tracev3_network_analyzer.py logdata_LiveData.tracev3
"""

import struct
import sys
import re
import json
from collections import defaultdict
from datetime import datetime

class TraceV3NetworkAnalyzer:
    """Extract network activity from Apple tracev3 binary log format"""
    
    def __init__(self, filepath):
        self.filepath = filepath
        self.domains = []
        self.ips = []
        self.urls = []
        self.network_errors = []
        self.cloudkit_events = []
        self.push_events = []
        self.suspicious_patterns = []
        
    def analyze(self):
        """Main analysis routine"""
        print("=" * 80)
        print("CVE-2026-25251 Network Activity Analyzer")
        print("=" * 80)
        print()
        
        with open(self.filepath, 'rb') as f:
            self.data = f.read()
        
        print(f"File size: {len(self.data):,} bytes")
        print()
        
        # Run all analysis modules
        self.extract_domains()
        self.extract_ips()
        self.extract_urls()
        self.extract_cloudkit_activity()
        self.extract_push_service()
        self.extract_network_errors()
        self.identify_suspicious_patterns()
        
        return self.generate_report()
    
    def extract_domains(self):
        """Extract domain names from binary data"""
        print("[*] Extracting domains...")
        
        # Convert to string for regex matching
        data_str = self.data.decode('ascii', errors='ignore')
        
        # Domain patterns
        patterns = [
            r'gateway\.icloud\.com',
            r'push\.apple\.com',
            r'[a-zA-Z0-9\-]+\.apple\.com',
            r'[a-zA-Z0-9\-]+\.icloud\.com',
            r'[a-zA-Z0-9\-]+\.akadns\.net',
            r'[a-zA-Z0-9\-]+\.mzstatic\.com'
        ]
        
        domain_set = set()
        domain_offsets = defaultdict(list)
        
        for pattern in patterns:
            for match in re.finditer(pattern, data_str):
                domain = match.group()
                offset = match.start()
                
                domain_set.add(domain)
                domain_offsets[domain].append(offset)
        
        # Store results
        for domain in sorted(domain_set):
            self.domains.append({
                'domain': domain,
                'count': len(domain_offsets[domain]),
                'offsets': domain_offsets[domain][:10]  # First 10 offsets
            })
        
        print(f"    Found {len(self.domains)} unique domains")
    
    def extract_ips(self):
        """Extract IP addresses from binary data"""
        print("[*] Extracting IP addresses...")
        
        data_str = self.data.decode('ascii', errors='ignore')
        ip_pattern = r'\b(?:\d{1,3}\.){3}\d{1,3}\b'
        
        ip_set = set()
        ip_offsets = defaultdict(list)
        
        for match in re.finditer(ip_pattern, data_str):
            ip = match.group()
            offset = match.start()
            
            # Validate IP (each octet 0-255)
            try:
                octets = [int(x) for x in ip.split('.')]
                if all(0 <= x <= 255 for x in octets):
                    # Skip obvious version numbers (like 1.0.0.0)
                    if not (octets[0] <= 20 and octets[1] == 0 and octets[2] == 0):
                        ip_set.add(ip)
                        ip_offsets[ip].append(offset)
            except:
                pass
        
        # Categorize IPs
        for ip in sorted(ip_set):
            octets = [int(x) for x in ip.split('.')]
            category = self._categorize_ip(octets)
            
            self.ips.append({
                'ip': ip,
                'category': category,
                'count': len(ip_offsets[ip]),
                'offsets': ip_offsets[ip][:5]
            })
        
        print(f"    Found {len(self.ips)} unique IP addresses")
    
    def _categorize_ip(self, octets):
        """Categorize IP address type"""
        # RFC1918 private addresses
        if octets[0] == 10:
            return 'private_10.x'
        if octets[0] == 172 and 16 <= octets[1] <= 31:
            return 'private_172.16-31.x'
        if octets[0] == 192 and octets[1] == 168:
            return 'private_192.168.x'
        
        # Loopback
        if octets[0] == 127:
            return 'loopback'
        
        # Link-local
        if octets[0] == 169 and octets[1] == 254:
            return 'link_local'
        
        # Suspicious non-standard
        if octets[0] < 100 and octets[1] == 1 and octets[2] == 1:
            return 'SUSPICIOUS_non_standard'
        
        return 'public'
    
    def extract_urls(self):
        """Extract full URLs from binary data"""
        print("[*] Extracting URLs...")
        
        data_str = self.data.decode('ascii', errors='ignore')
        url_pattern = r'https?://[a-zA-Z0-9\-\./_]+(?:\?[a-zA-Z0-9\-\./_=&]*)?'
        
        url_set = set()
        url_offsets = defaultdict(list)
        
        for match in re.finditer(url_pattern, data_str):
            url = match.group()
            offset = match.start()
            
            # Clean up URL (remove trailing garbage)
            url = re.sub(r'[^a-zA-Z0-9\-\./_:?=&]+$', '', url)
            
            if len(url) > 10:  # Skip very short matches
                url_set.add(url)
                url_offsets[url].append(offset)
        
        # Store results
        for url in sorted(url_set):
            self.urls.append({
                'url': url,
                'count': len(url_offsets[url]),
                'offsets': url_offsets[url][:5]
            })
        
        print(f"    Found {len(self.urls)} unique URLs")
    
    def extract_cloudkit_activity(self):
        """Extract CloudKit API activity"""
        print("[*] Analyzing CloudKit activity...")
        
        data_str = self.data.decode('ascii', errors='ignore')
        
        # CloudKit API patterns
        cloudkit_patterns = [
            (r'/ckdatabase/api/client/record/retrieve', 'record_retrieve'),
            (r'/ckdatabase/api/record/sync', 'record_sync'),
            (r'/ckdatabase/api/client/zone/retrieve', 'zone_retrieve'),
            (r'cloudkit', 'general_reference'),
            (r'com\.apple\.cloudd', 'daemon_activity'),
            (r'CKOperation', 'operation'),
            (r'CloudKit', 'framework_reference')
        ]
        
        for pattern, event_type in cloudkit_patterns:
            count = 0
            offsets = []
            
            for match in re.finditer(pattern, data_str, re.IGNORECASE):
                count += 1
                offsets.append(match.start())
            
            if count > 0:
                self.cloudkit_events.append({
                    'type': event_type,
                    'pattern': pattern,
                    'count': count,
                    'offsets': offsets[:10]
                })
        
        total_events = sum(e['count'] for e in self.cloudkit_events)
        print(f"    Found {total_events} CloudKit events across {len(self.cloudkit_events)} types")
    
    def extract_push_service(self):
        """Extract Apple Push Service activity"""
        print("[*] Analyzing Apple Push Service...")
        
        data_str = self.data.decode('ascii', errors='ignore')
        
        push_patterns = [
            (r'push\.apple\.com', 'push_domain'),
            (r'com\.apple\.apsd', 'push_daemon'),
            (r'APSConnection', 'connection'),
            (r'PersistentConnection', 'persistent_connection')
        ]
        
        for pattern, event_type in push_patterns:
            count = 0
            offsets = []
            
            for match in re.finditer(pattern, data_str, re.IGNORECASE):
                count += 1
                offsets.append(match.start())
            
            if count > 0:
                self.push_events.append({
                    'type': event_type,
                    'pattern': pattern,
                    'count': count,
                    'offsets': offsets[:10]
                })
        
        total_events = sum(e['count'] for e in self.push_events)
        print(f"    Found {total_events} Push Service events")
    
    def extract_network_errors(self):
        """Extract network error codes and patterns"""
        print("[*] Analyzing network errors...")
        
        data_str = self.data.decode('ascii', errors='ignore')
        
        # Common iOS network error patterns
        error_patterns = [
            (r'NSURLErrorDomain/-1009', 'offline_error'),
            (r'NSURLErrorDomain/-1001', 'timeout_error'),
            (r'NSURLErrorDomain/-1004', 'cannot_connect'),
            (r'NSURLErrorDomain/-1005', 'network_connection_lost'),
            (r'NSURLErrorDomain/-1200', 'ssl_error'),
            (r'The Internet connection appears to be offline', 'offline_message'),
            (r'Could not connect to the server', 'connection_failed')
        ]
        
        for pattern, error_type in error_patterns:
            count = 0
            offsets = []
            
            for match in re.finditer(pattern, data_str, re.IGNORECASE):
                count += 1
                offsets.append(match.start())
            
            if count > 0:
                self.network_errors.append({
                    'type': error_type,
                    'pattern': pattern,
                    'count': count,
                    'offsets': offsets[:10]
                })
        
        total_errors = sum(e['count'] for e in self.network_errors)
        print(f"    Found {total_errors} network error events")
    
    def identify_suspicious_patterns(self):
        """Identify suspicious network patterns"""
        print("[*] Identifying suspicious patterns...")
        
        # Check for suspicious IPs
        suspicious_ips = [ip for ip in self.ips if 'SUSPICIOUS' in ip['category']]
        if suspicious_ips:
            self.suspicious_patterns.append({
                'type': 'non_standard_ips',
                'description': 'IP addresses outside RFC1918 private ranges',
                'count': len(suspicious_ips),
                'details': suspicious_ips
            })
        
        # Check for excessive network errors
        total_errors = sum(e['count'] for e in self.network_errors)
        if total_errors > 5:
            self.suspicious_patterns.append({
                'type': 'excessive_network_errors',
                'description': 'High number of connection failures',
                'count': total_errors,
                'details': self.network_errors
            })
        
        # Check for CloudKit activity (could be normal or exfiltration)
        cloudkit_total = sum(e['count'] for e in self.cloudkit_events)
        if cloudkit_total > 20:
            self.suspicious_patterns.append({
                'type': 'high_cloudkit_activity',
                'description': 'Elevated CloudKit API usage',
                'count': cloudkit_total,
                'details': self.cloudkit_events
            })
        
        print(f"    Identified {len(self.suspicious_patterns)} suspicious patterns")
    
    def generate_report(self):
        """Generate comprehensive network analysis report"""
        
        report = {
            'metadata': {
                'file': self.filepath,
                'size_bytes': len(self.data),
                'analysis_date': datetime.now().isoformat()
            },
            'summary': {
                'domains': len(self.domains),
                'ips': len(self.ips),
                'urls': len(self.urls),
                'cloudkit_events': sum(e['count'] for e in self.cloudkit_events),
                'push_events': sum(e['count'] for e in self.push_events),
                'network_errors': sum(e['count'] for e in self.network_errors),
                'suspicious_patterns': len(self.suspicious_patterns)
            },
            'findings': {
                'domains': self.domains,
                'ips': self.ips,
                'urls': self.urls,
                'cloudkit_activity': self.cloudkit_events,
                'push_service': self.push_events,
                'network_errors': self.network_errors,
                'suspicious_patterns': self.suspicious_patterns
            }
        }
        
        return report
    
    def print_report(self, report):
        """Print human-readable report"""
        
        print("\n" + "=" * 80)
        print("NETWORK ANALYSIS REPORT")
        print("=" * 80)
        print()
        
        print("SUMMARY")
        print("-" * 80)
        print(f"Domains found:         {report['summary']['domains']}")
        print(f"IP addresses:          {report['summary']['ips']}")
        print(f"URLs extracted:        {report['summary']['urls']}")
        print(f"CloudKit events:       {report['summary']['cloudkit_events']}")
        print(f"Push Service events:   {report['summary']['push_events']}")
        print(f"Network errors:        {report['summary']['network_errors']}")
        print(f"Suspicious patterns:   {report['summary']['suspicious_patterns']}")
        print()
        
        # Critical findings
        print("CRITICAL NETWORK ENDPOINTS")
        print("-" * 80)
        
        # iCloud gateway
        gateway_domains = [d for d in self.domains if 'gateway.icloud.com' in d['domain']]
        if gateway_domains:
            for d in gateway_domains:
                print(f"✓ {d['domain']:<30} ({d['count']} occurrences)")
                print(f"  Offsets: {', '.join(f'0x{o:08x}' for o in d['offsets'][:5])}")
        
        # Push service
        push_domains = [d for d in self.domains if 'push.apple.com' in d['domain']]
        if push_domains:
            for d in push_domains:
                print(f"✓ {d['domain']:<30} ({d['count']} occurrences)")
                print(f"  Offsets: {', '.join(f'0x{o:08x}' for o in d['offsets'][:5])}")
        print()
        
        # CloudKit API endpoints
        if self.urls:
            print("CLOUDKIT API ENDPOINTS")
            print("-" * 80)
            cloudkit_urls = [u for u in self.urls if 'ckdatabase' in u['url'].lower()]
            for u in cloudkit_urls[:5]:
                print(f"• {u['url']}")
                print(f"  Count: {u['count']}, First offset: 0x{u['offsets'][0]:08x}")
            print()
        
        # Network errors
        if self.network_errors:
            print("NETWORK ERROR PATTERNS")
            print("-" * 80)
            for err in self.network_errors:
                print(f"[{err['type']}] {err['count']} occurrences")
                if err['offsets']:
                    print(f"  First offset: 0x{err['offsets'][0]:08x}")
            print()
        
        # Suspicious patterns
        if self.suspicious_patterns:
            print("⚠️  SUSPICIOUS PATTERNS DETECTED")
            print("-" * 80)
            for pattern in self.suspicious_patterns:
                print(f"[{pattern['type']}]")
                print(f"  {pattern['description']}")
                print(f"  Count: {pattern['count']}")
            print()
        
        print("=" * 80)
        print("EXPLOITATION INDICATORS")
        print("=" * 80)
        print()
        
        # Check for C2 indicators
        has_gateway = any('gateway.icloud.com' in d['domain'] for d in self.domains)
        has_errors = len(self.network_errors) > 0
        has_cloudkit = len(self.cloudkit_events) > 0
        
        if has_gateway and has_errors:
            print("✓ CONFIRMED: iCloud gateway connections with error patterns")
            print("  → Suggests unauthorized background connection attempts")
            print()
        
        if has_cloudkit and has_gateway:
            print("✓ CONFIRMED: CloudKit API activity to gateway.icloud.com")
            print("  → Data exfiltration channel identified")
            print()
        
        if self.push_events:
            print("✓ DETECTED: Apple Push Service activity")
            print("  → Potential C2 notification channel")
            print()
        
        print("=" * 80)
        print("NEXT STEPS")
        print("=" * 80)
        print("1. Correlate network timestamps with debug events (tracev3_exploitation_analyzer.py)")
        print("2. Extract CloudKit container IDs from full sysdump")
        print("3. Request Apple access logs for gateway.icloud.com (legal process)")
        print("4. Monitor live network traffic if exploitation ongoing")
        print()


def main():
    if len(sys.argv) < 2:
        print("Usage: python3 tracev3_network_analyzer.py <logdata_LiveData.tracev3>")
        sys.exit(1)
    
    trace_file = sys.argv[1]
    
    analyzer = TraceV3NetworkAnalyzer(trace_file)
    report = analyzer.analyze()
    
    print()
    analyzer.print_report(report)
    
    # Save JSON report
    output_file = trace_file.replace('.tracev3', '_NETWORK_REPORT.json')
    try:
        with open(output_file, 'w') as f:
            json.dump(report, f, indent=2, default=str)
        print(f"\nFull report saved to: {output_file}")
    except:
        # If can't write to same directory, try current directory
        output_file = 'NETWORK_REPORT.json'
        with open(output_file, 'w') as f:
            json.dump(report, f, indent=2, default=str)
        print(f"\nFull report saved to: {output_file}")


if __name__ == '__main__':
    main()
